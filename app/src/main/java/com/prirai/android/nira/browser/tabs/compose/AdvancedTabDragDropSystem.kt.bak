package com.prirai.android.nira.browser.tabs.compose

import androidx.compose.animation.core.*
import androidx.compose.foundation.gestures.detectDragGesturesAfterLongPress
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.layout.positionInRoot
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.zIndex
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlin.math.abs

/**
 * Advanced drag-drop system with animated reordering and threshold-based grouping.
 * Inspired by sh.calvin.reorderable library with custom enhancements.
 */

/**
 * Drag operation types
 */
sealed class DragOperation {
    object None : DragOperation()
    data class Reorder(val targetIndex: Int) : DragOperation()
    data class GroupWith(val targetId: String, val targetIndex: Int) : DragOperation()
    data class MoveToGroup(val groupId: String) : DragOperation()
    data class UngroupAndReorder(val targetIndex: Int) : DragOperation()
}

/**
 * Item metadata for drag calculations
 */
data class ItemMetadata(
    val id: String,
    val position: Offset,
    val size: IntSize,
    val index: Int,
    val isGroupHeader: Boolean = false,
    val groupId: String? = null,
    val isInGroup: Boolean = false
)

/**
 * Drag feedback state
 */
data class DragFeedbackState(
    val operation: DragOperation = DragOperation.None,
    val targetScale: Float = 1f,
    val insertionLinePosition: Float? = null,
    val showGroupingHint: Boolean = false
)

/**
 * Main drag-drop state manager
 */
class AdvancedDragDropState {
    // Current drag state
    var isDragging by mutableStateOf(false)
        private set
    
    var draggedItemId by mutableStateOf<String?>(null)
        private set
    
    var draggedFromIndex by mutableStateOf(-1)
        private set
    
    var draggedFromGroupId by mutableStateOf<String?>(null)
        private set
    
    var dragOffset by mutableStateOf(Offset.Zero)
        private set
    
    var draggedItemInitialPosition by mutableStateOf(Offset.Zero)
        private set
    
    // Target/hover state
    var hoveredItemId by mutableStateOf<String?>(null)
        private set
    
    var hoveredIndex by mutableStateOf(-1)
        private set
    
    // Feedback state
    var feedbackState by mutableStateOf(DragFeedbackState())
        private set
    
    // Item tracking
    private val items = mutableStateMapOf<String, ItemMetadata>()
    
    // Simple offset map instead of Animatable - will be animated by Compose itself
    private val targetOffsets = mutableStateMapOf<String, Float>()
    
    // Thresholds
    private val GROUPING_THRESHOLD_PERCENT = 0.30f // 30% overlap triggers grouping
    private val REORDER_THRESHOLD_PERCENT = 0.50f  // 50% overlap triggers reordering
    
    /**
     * Register an item with its position and size
     */
    fun registerItem(
        id: String,
        position: Offset,
        size: IntSize,
        index: Int,
        isGroupHeader: Boolean = false,
        groupId: String? = null,
        isInGroup: Boolean = false
    ) {
        items[id] = ItemMetadata(id, position, size, index, isGroupHeader, groupId, isInGroup)
        
        // Initialize offset if not exists
        if (!targetOffsets.containsKey(id)) {
            targetOffsets[id] = 0f
        }
    }
    
    /**
     * Get animated offset for an item - to be used with animateFloatAsState in Compose
     */
    fun getTargetOffset(id: String): Float {
        return targetOffsets[id] ?: 0f
    }
    
    /**
     * Start dragging an item
     */
    fun startDrag(itemId: String, fromIndex: Int, fromGroupId: String?) {
        isDragging = true
        draggedItemId = itemId
        draggedFromIndex = fromIndex
        draggedFromGroupId = fromGroupId
        dragOffset = Offset.Zero
        
        val item = items[itemId]
        if (item != null) {
            draggedItemInitialPosition = item.position
        }
    }
    
    /**
     * Update drag position and calculate feedback
     */
    suspend fun updateDrag(offset: Offset) {
        if (!isDragging) return
        
        dragOffset += offset
        
        val draggedItem = items[draggedItemId] ?: return
        val currentDragPosition = draggedItem.position + dragOffset
        
        // Find what we're hovering over
        val (hoveredId, hoveredIdx, operation) = calculateHoverTarget(currentDragPosition, draggedItem)
        
        hoveredItemId = hoveredId
        hoveredIndex = hoveredIdx
        
        // Update feedback state
        feedbackState = when (operation) {
            is DragOperation.GroupWith -> DragFeedbackState(
                operation = operation,
                targetScale = 1.05f,
                showGroupingHint = true
            )
            is DragOperation.Reorder -> {
                val targetItem = items[hoveredId]
                val insertionY = if (targetItem != null) {
                    if (hoveredIdx > draggedFromIndex) {
                        targetItem.position.y + targetItem.size.height
                    } else {
                        targetItem.position.y
                    }
                } else null
                
                DragFeedbackState(
                    operation = operation,
                    insertionLinePosition = insertionY
                )
            }
            is DragOperation.MoveToGroup -> DragFeedbackState(
                operation = operation,
                targetScale = 1.03f
            )
            is DragOperation.UngroupAndReorder -> DragFeedbackState(
                operation = operation,
                insertionLinePosition = calculateInsertionLine(hoveredIdx)
            )
            DragOperation.None -> DragFeedbackState()
        }
        
        // Update target offsets for reordering
        if (operation is DragOperation.Reorder) {
            updateReorderOffsets(draggedFromIndex, hoveredIdx)
        } else {
            // Reset offsets
            items.keys.forEach { id ->
                if (id != draggedItemId) {
                    targetOffsets[id] = 0f
                }
            }
        }
    }
    
    /**
     * Calculate what operation should happen based on finger position
     */
    private fun calculateHoverTarget(
        fingerPos: Offset,
        draggedItem: ItemMetadata
    ): Triple<String?, Int, DragOperation> {
        var bestMatch: ItemMetadata? = null
        var bestDistance = Float.MAX_VALUE
        
        items.values.forEach { item ->
            if (item.id == draggedItemId) return@forEach
            
            // Calculate visual position (original + offset)
            val visualState = itemVisualStates[item.id] ?: return@forEach
            val itemVisualY = item.position.y + visualState.offset
            val itemCenterY = itemVisualY + (item.size.height / 2f)
            
            // Distance from finger to item center
            val distance = kotlin.math.abs(fingerPos.y - itemCenterY)
            
            if (distance < bestDistance) {
                bestDistance = distance
                bestMatch = item
            }
        }
        
        val target = bestMatch ?: return Triple(null, -1, DragOperation.None)
        
        // Calculate overlap percentage based on distance
        val maxDistance = (draggedItem.size.height + target.size.height) / 2f
        if (bestDistance > maxDistance) return Triple(null, -1, DragOperation.None)
        
        val overlapPercent = 1f - (bestDistance / maxDistance)
        
        // Determine operation based on overlap and item types
        val operation = when {
            // Case 1: Hovering over group header -> move to that group
            target.isGroupHeader -> {
                if (overlapPercent > 0.2f) {
                    DragOperation.MoveToGroup(target.groupId ?: target.id)
                } else {
                    DragOperation.None
                }
            }
            
            // Case 2: Grouped tab over ungrouped tab (0-30%) -> create new group with both
            draggedItem.isInGroup && !target.isInGroup && overlapPercent in (0.05f..GROUPING_THRESHOLD_PERCENT) -> {
                DragOperation.GroupWith(target.id, target.index)
            }
            
            // Case 3: Low overlap (0-30%) over ungrouped tab -> group with it
            !target.isInGroup && !draggedItem.isInGroup && overlapPercent in (0.05f..GROUPING_THRESHOLD_PERCENT) -> {
                DragOperation.GroupWith(target.id, target.index)
            }
            
            // Case 4: High overlap (30%+) -> reorder
            overlapPercent > GROUPING_THRESHOLD_PERCENT -> {
                if (draggedItem.isInGroup && !target.isInGroup && draggedItem.groupId != null) {
                    // Dragging from group to ungrouped area -> ungroup and reorder
                    DragOperation.UngroupAndReorder(target.index)
                } else if (draggedItem.isInGroup && target.isInGroup && draggedItem.groupId == target.groupId) {
                    // Reordering within same group
                    DragOperation.Reorder(target.index)
                } else if (!draggedItem.isInGroup && !target.isInGroup) {
                    // Reordering ungrouped tabs
                    DragOperation.Reorder(target.index)
                } else {
                    DragOperation.None
                }
            }
            
            else -> DragOperation.None
        }
        
        return Triple(target.id, target.index, operation)
    }
    
    /**
     * Calculate overlap between dragged item and target
     */
    private fun calculateOverlap(dragPosition: Offset, dragSize: IntSize, target: ItemMetadata): Float {
        // Calculate center of dragged item
        val dragCenterY = dragPosition.y + (dragSize.height / 2f)
        
        // Account for target's visual offset (from animations)
        val targetVisualOffset = targetOffsets[target.id] ?: 0f
        val targetTop = target.position.y + targetVisualOffset
        val targetBottom = target.position.y + target.size.height + targetVisualOffset
        val targetCenterY = (targetTop + targetBottom) / 2f
        
        // Calculate distance from drag center to target center
        val distance = kotlin.math.abs(dragCenterY - targetCenterY)
        val maxDistance = (dragSize.height + target.size.height) / 2f
        
        // If centers are far apart, no overlap
        if (distance > maxDistance) return 0f
        
        // Return overlap as a percentage-like value
        // When drag center is at target center, overlap = full height
        // When drag center is at target edge, overlap reduces
        val overlapRatio = 1f - (distance / maxDistance)
        return dragSize.height.toFloat() * overlapRatio
    }
    
    /**
     * Update target offsets for reordering
     */
    private fun updateReorderOffsets(fromIndex: Int, toIndex: Int) {
        if (fromIndex == toIndex) return
        
        val draggedItem = items[draggedItemId] ?: return
        val itemHeight = draggedItem.size.height.toFloat()
        
        items.values.forEach { item ->
            if (item.id == draggedItemId) return@forEach
            
            val targetOffset = when {
                // Moving down: items between fromIndex and toIndex move up
                toIndex > fromIndex && item.index in (fromIndex + 1)..toIndex -> -itemHeight
                
                // Moving up: items between toIndex and fromIndex move down
                toIndex < fromIndex && item.index in toIndex until fromIndex -> itemHeight
                
                else -> 0f
            }
            
            targetOffsets[item.id] = targetOffset
        }
    }
    
    /**
     * Calculate insertion line position for given index
     */
    private fun calculateInsertionLine(index: Int): Float? {
        val item = items.values.find { it.index == index } ?: return null
        return item.position.y
    }
    
    /**
     * End drag and return the operation to perform
     */
    suspend fun endDrag(): DragOperation {
        val operation = feedbackState.operation
        
        // Reset state
        isDragging = false
        draggedItemId = null
        draggedFromIndex = -1
        draggedFromGroupId = null
        dragOffset = Offset.Zero
        hoveredItemId = null
        hoveredIndex = -1
        feedbackState = DragFeedbackState()
        
        // Reset all offsets
        targetOffsets.keys.forEach { id ->
            targetOffsets[id] = 0f
        }
        
        return operation
    }
    
    /**
     * Check if an item is currently being dragged
     */
    fun isDraggingItem(id: String): Boolean {
        return isDragging && draggedItemId == id
    }
    
    /**
     * Check if an item is the hover target
     */
    fun isHoverTarget(id: String): Boolean {
        return hoveredItemId == id && feedbackState.operation != DragOperation.None
    }
    
    /**
     * Get scale for hover target
     */
    fun getTargetScale(id: String): Float {
        return if (isHoverTarget(id)) feedbackState.targetScale else 1f
    }
}

@Composable
fun rememberAdvancedDragDropState(): AdvancedDragDropState {
    return remember { AdvancedDragDropState() }
}

/**
 * Modifier for draggable items with advanced features
 */
fun Modifier.advancedDraggable(
    id: String,
    index: Int,
    dragDropState: AdvancedDragDropState,
    isGroupHeader: Boolean = false,
    groupId: String? = null,
    isInGroup: Boolean = false,
    enabled: Boolean = true,
    onDragEnd: (DragOperation) -> Unit = {}
): Modifier = this
    .onGloballyPositioned { coordinates ->
        dragDropState.registerItem(
            id = id,
            position = coordinates.positionInRoot(),
            size = coordinates.size,
            index = index,
            isGroupHeader = isGroupHeader,
            groupId = groupId,
            isInGroup = isInGroup
        )
    }
    .then(
        if (enabled) {
            Modifier.pointerInput(id) {
                detectDragGesturesAfterLongPress(
                    onDragStart = {
                        dragDropState.startDrag(id, index, groupId)
                    },
                    onDrag = { change, dragAmount ->
                        change.consume()
                        // Fire and forget - don't wait for completion
                        kotlinx.coroutines.GlobalScope.launch {
                            dragDropState.updateDrag(dragAmount)
                        }
                    },
                    onDragEnd = {
                        // Fire and forget - the operation will be communicated via callback
                        kotlinx.coroutines.GlobalScope.launch {
                            val operation = dragDropState.endDrag()
                            onDragEnd(operation)
                        }
                    },
                    onDragCancel = {
                        kotlinx.coroutines.GlobalScope.launch {
                            dragDropState.endDrag()
                        }
                    }
                )
            }
        } else {
            Modifier
        }
    )
    .graphicsLayer {
        val isDragging = dragDropState.isDraggingItem(id)
        val isTarget = dragDropState.isHoverTarget(id)
        
        // Apply drag offset for the dragged item
        if (isDragging) {
            translationX = dragDropState.dragOffset.x
            translationY = dragDropState.dragOffset.y
            scaleX = 1.05f
            scaleY = 1.05f
            shadowElevation = 8f
        } else {
            // Apply target offset for reordering - Compose will animate this automatically
            translationY = dragDropState.getTargetOffset(id)
            
            // Apply scale for hover target
            if (isTarget) {
                scaleX = dragDropState.getTargetScale(id)
                scaleY = dragDropState.getTargetScale(id)
            }
        }
    }
    .zIndex(if (dragDropState.isDraggingItem(id)) 1f else 0f)
